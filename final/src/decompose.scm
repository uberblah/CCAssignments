(use-modules (ice-9 match)
             (srfi srfi-26))

(define (lookup name alist)
  (define r (assoc name alist))
  (if r (cdr r) r))

(define (impmap f l)
  (cond ((pair? l) (cons (f (car l))
                         (impmap f (cdr l))))
        ((null? l) '())
        (else (f l))))

(define (toplevel-unbegin code)
  (define (begin-rec code)
    (match code
           (('begin . rest) (toplevel-unbegin rest))
           (x (list x))))
  (apply append (map begin-rec code)))

(define (unique-symbol sym)
  (make-symbol (symbol->string sym)))

;(define unique-symbol id)

(define (uniquify code bindings)
  (define (bound-vars code vars)
    (define (bound-vars-body code vars)
      (match code
             ((('define name . _) . body)
              (bound-vars-body body (cons name vars)))
             (x vars)))
    (match code
           (('lambda (arg . argrest) . body)
            (bound-vars `(lambda ,argrest . ,body)
                        (cons arg vars)))
           (('lambda () . body)
            (bound-vars body vars))
           (('lambda vararg . body)
            (bound-vars body (cons vararg vars)))
           (('let ((name . expr) . rest) . body)
            (bound-vars `(let ,rest . ,body) (cons name vars)))
           (('let () . body)
            (bound-vars body vars))
           (('quote . rest) code)
           (_ (bound-vars-body code vars))))
  (define bound (bound-vars code '()))
  (define inner-bindings (map (lambda (x) (cons x (unique-symbol x))) bound))
  (define (uniquify-rec code bindings)
    (match code
           (('lambda . rest) (uniquify code bindings))
           (('let . rest) (uniquify code bindings))
           (('quote . rest) code)
           ((a . b) (impmap
                      (cut uniquify-rec <> bindings)
                      code))
           (x (if (symbol? x)
                (let ((v (lookup x bindings)))
                  (if v v x))
                x))))
  (impmap (cut uniquify-rec <> (append inner-bindings bindings)) code))

(define (stack-vars code)
  (define (rec code vars)
    (match code
           ((('define name . expr) . rest)
            (cons name (rec rest (rec expr vars))))
           (('let () body)
            (rec body vars))
           (('let ((name . expr) . rest) . body)
            (rec `(let ,rest . ,body) (rec expr (cons name vars))))
           (('lambda _) vars)
           ((a . b) (rec b (rec a vars)))
           (_ vars)))
  (rec code '()))

(define (dearg code) ; turns all functions into functions with exactly one vararg
  (define t (unique-symbol 'argtmp))
  (match code
         (('lambda (arg1 arg2) . body)
           `(lambda ,t
              (let ((,arg1 (car ,t))
                    (,arg2 (car (cdr ,t)))) . ,body)))
         (('lambda (arg) . body)
          `(lambda ,t (let ((,arg (car ,t))) . ,body)))
         (('lambda (arg1 arg2 . rest) . body)
          (dearg `(lambda (,arg1 . ,t)
                    (let ((,arg2 (car ,t))
                          (,rest (cdr ,t))) . ,body))))
         (('lambda (arg . vararg) . body)
          `(lambda ,t
             (let ((,arg (car ,t))
                   (,vararg (cdr ,t))) . ,body)))
         (('lambda () . body) `(lambda ,t . ,body))
         (('lambda vararg . body) code)))
