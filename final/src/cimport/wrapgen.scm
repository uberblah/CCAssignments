#!/usr/bin/guile
!#

(use-modules (ice-9 pretty-print))
(use-modules (ice-9 format))

; general utilities
(define (loadscm filename)
    (read (open-input-file filename))
)
(define (displaynl str) (display str) (newline))
(define (noimp name args)
    (displaynl (string-append "## " name " not yet implemented"))
    (displaynl "> Reached the following state...")
    (map (lambda (x) (display "> ") (displaynl x)) args)
    '()
)
(define (fold-right proc init lst)
    (if (equal? lst '())
        init
        (fold-right proc (proc init (car lst)) (cdr lst))
))
(define (aget alist key)
    (cadar (filter (lambda (x) (equal? (car x) key)) alist))
)
(define (ado alist kget val) ((aget alist (kget val)) val))
(define (afind alist key)
    (if (equal? alist '())
        #f
        (if (equal? (caar alist) key)
            (cadar alist)
            (afind (cdr alist) key)
)))
(define (dado alist kget val)
    (define found (afind alist (kget val)))
    (if (eq? (cdr found) '())
        ((car found) val)
        ((cadr found) val)
))
(define (llen lst) (fold-right (lambda (x y) (+ x 1)) 0 lst))
(define (count lst item)
    (define (rec lst item count)
        (if (equal? lst '())
            count
            (rec (cdr lst) item (if
                (equal? (car lst) item)
                (+ count 1)
                count
    ))))
    (rec lst item 0)
)
(define (nth lst n)
    (if (equal? n 1)
        (car lst)
        (nth (cdr lst) (- n 1))
    )
)
(define (pappend l1 l2)
   `(,(append (car l1) (car l2)) ,(append (cadr l1) (cadr l2)))
)
(define (one-of item lst)
    (if (equal? lst '())
        #f
        (if (equal? item (car lst))
            #t
            (one-of item (cdr lst))
)))
(define (sappend s1 s2)
    (string->symbol (string-append (symbol->string s1) (symbol->string s2)))
)
(define (find-in item lst)
    (if (equal? lst '())
       '()
        (if (equal? item (car lst))
            item
            (find-in item (cdr lst))
)))
(define (dappend delim)
    (lambda (x y) (string-append x delim y))
)

; END GOAL: TO PRODUCE A C FILE CONTAINING WRAPPERS FOR ALL DECLARED ITEMS
(define scmheader "#include \"scm.h\"\n")

(define cmd (command-line))
(define decls (loadfile (cadr cmd)))
(define outfile (caddr cmd))

(define (dofunc node name)
    (define ret (cadr node))
    (define arg (caddr node))
    
)
(define (dovalue node name)

)
(define (dotopfunc node name)
    (define ret (cadr node))
    (define arg (caddr node))
    
)
(define (dotopvalue node name)
    (define type (car node))
    
)

(define (getwraps decls file)
    (define (getwrap decl)
        (define (item->str node name)
            (define type (car node))
            (if (eq? type 'func)
                (dofunc node name)
                (dovalue node name)
            )
        )
        (define (decl->str decl)
            (define name (car decl))
            (define value (cadr decl))
            (define type (car value))
            (if (eq? type 'func)
                (dotopfunc node name)
                (dotopvalue node name)
            )
        )
        (decl->str decl)
    )
    (map getwrap decls)
)

